@page "/voronoi/delaunay"
@using System.Globalization
@using System.Numerics
@using System.Text

<PageTitle>Delaunay Triangulation</PageTitle>

<h1>Delaunay Triangulation</h1>

<main>
	<section id="configuration">
		<h2>Configuration</h2>

		<h3>Voronoi Diagram</h3>

		<form>
			<label for="seed">Seed</label>
			<input type="number" id="seed" @bind="Seed" />
		</form>

		<form>
			<label for="input_site_count">Site Count</label>
			<input type="number" id="input_site_count" @bind="SiteCount" />
		</form>

		<button type="button" onclick="@(() => @GenerateSites())">Generate</button>
	</section>

	<section id="result">
		<h2>Result Image</h2>

		<svg viewBox="0 0 100 100">
			<!--Sites-->
			@foreach (var site in sites)
			{
				<circle class="site"
					cx="@site.X.ToString(CultureInfo.InvariantCulture)"
					cy="@site.Y.ToString(CultureInfo.InvariantCulture)"
					r="1.5" />
			}

			@foreach (var circle in Circles)
			{
				<circle class="circle"
					cx="@circle.Center.X.ToString(CultureInfo.InvariantCulture)"
					cy="@circle.Center.Y.ToString(CultureInfo.InvariantCulture)"
					r="@circle.Radius.ToString(CultureInfo.InvariantCulture)" />

				<circle class="circle-center"
					cx="@circle.Center.X.ToString(CultureInfo.InvariantCulture)"
					cy="@circle.Center.Y.ToString(CultureInfo.InvariantCulture)"
					r="1" />
			}

		</svg>

		<hr/>

		<h3>Controls</h3>
	</section>
</main>

@code {
	private const float MAX_SIZE = 100f;
	private const int DEFAULT_SITE_COUNT = 10;

	public int Seed { get; set; } = 423;
	public int SiteCount { get; set; } = DEFAULT_SITE_COUNT;

	private Vector2[] sites = new Vector2[DEFAULT_SITE_COUNT];

	private IEnumerable<Circle> Circles => sites
		//Tutte le terne possibili di punti
		.DifferentCombinations(3)
		//Calcola il circumcerchio
		.Select(sites =>
		{
			var s = sites.ToArray();
			var result = TryGetCircleByPoints(s[0], s[1], s[2], out Circle c);
			return (result, c);
		})
		.Where(t => t.result)
		.Select(t => t.c)
		//Solo i cerchi con nessun sito al loro interno
		.Where(circle => !sites
			.Select(site => MathF.Sqrt(MathF.Pow(circle.Center.X - site.X, 2) + MathF.Pow(circle.Center.Y - site.Y, 2)))
			.Where(distance => distance < (circle.Radius - 0.1)).Any());

	protected override void OnInitialized()
	{
		GenerateSites();
	}

	private void GenerateSites()
	{
		sites = new Vector2[SiteCount];
		Random r = new Random(Seed);
		foreach (int i in Enumerable.Range(0, SiteCount))
		{
			float x = r.NextSingle() * MAX_SIZE;
			float y = r.NextSingle() * MAX_SIZE;
			sites[i] = new(x, y);
		}
		StateHasChanged();
	}

	struct Circle
	{
		public Vector2 Center { get; init; }
		public float Radius { get; init; }
	}

	private void Test()
	{
		var a = sites.SelectMany(
			(element, index) =>
				sites.Skip(index + 1)
		);
	}



	private bool TryGetCircleByPoints(Vector2 p1, Vector2 p2, Vector2 p3, out Circle circle)
	{
		// Eliminazione gaussiana.
		float[] m =
		[
			2*p1.X, 2*p1.Y, 1, -(p1.X * p1.X + p1.Y * p1.Y),
		2*p2.X, 2*p2.Y, 1, -(p2.X * p2.X + p2.Y * p2.Y),
		2*p3.X, 2*p3.Y, 1, -(p3.X * p3.X + p3.Y * p3.Y),
	];
		float n = 0;
		// Portiamo in forma triangolare
		// L2 -> L2 - L1 * (L2_0/L1_0)
		n = m[4] / m[0];
		for (int i = 0; i<4; i++) m[4 + i] -= m[0 + i] * n;

		// L3 -> L3 - L1 * (L3_0/L1_0)
		n = m[8] / m[0];
		for (int i = 0; i<4; i++) m[8 + i] -= m[0 + i] * n;

		// L3 -> L3 - L2 * (L3_1/L2_1)
		n = m[9] / m[5];
		for (int i = 0; i<4; i++) m[8 + i] -= m[4 + i] * n;
		// Ci fermiamo alla eliminazione di Gauss invece di proseguire con la eliminazione di Gauss-Jordan
		var c = m[11] / m[10];
		var b = (m[7] - m[6] * c) / m[5];
		var a = (m[3] - m[1] * b - m[2] * c) / m[0];

		// TODO: Check for edge cases (colinear points)

		circle = new Circle()
			{
				Center = new Vector2(-a, -b),
				Radius = MathF.Sqrt(-a * -a + -b * -b - c)
			};
		return true;
	}
}
